{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Golang笔记","slug":"Golang","date":"2021-06-26T05:55:08.704Z","updated":"2021-06-26T05:55:08.742Z","comments":true,"path":"2021/06/26/Golang/","link":"","permalink":"http://example.com/2021/06/26/Golang/","excerpt":"","text":"Golang函数函数参数的传递方式基本介绍​ 值类型参数默认就是值传递，而引用类型参数默认就是引用传递 两种传递方式 值传递 引用传递 其实，不管是值传递还是引用传递，传递给函数的都是变量副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址效率高，因为数 据量小，而值拷贝决定拷贝的数据量大小，数据量越大，效率越低 值类型和引用类型 ​ 值类型：基本数据类型int系列，float系列，bool，string，数组和结构体struct ​ 引用类型：指针，slice切片，map，管道chan，interface等都是引用赋值 字符串常用系统函数​ 1. 统计字符串的长度，按字节 len（str） 123456func main() &#123; //统计字符串长度，按字节len（str） //golang统一为UTF-8编码，字母和数字占一个字节，汉字占3个字节 str := &quot;word刘阳&quot; fmt.Println(&quot;str len=&quot;,len(str)) //输出 10&#125; ​ 2. 字符串便利，同时处理有中文的问题 r:=[]rune[str] 1234567func main()&#123; str2 := &quot;word刘阳&quot; r := []rune(str2) for i := 0; i &lt; len(r); i++ &#123; fmt.Printf(&quot;字符=%c\\n&quot;,r[i]) &#125;&#125; ​ 3. 字符串转整数：n,err := strconv.Atoi(“12”) 1234567//字符串转整数：n,err := strconv.Atoi(&quot;12&quot;)n,err := strconv.Atoi(&quot;123&quot;)if err != nil&#123; fmt.Println(&quot;转换错误&quot;,err)&#125;else&#123; fmt.Println(&quot;结果=&quot;,n)&#125; 14. ​ 整数转字符串：str := strconv.Itoa(&quot;123312&quot;) 123//整数转字符串：str := strconv.Itoa(&quot;123312&quot;)str3 := strconv.Itoa(1111)fmt.Println(&quot;字符串=&quot;,str3) ​ 5. 字符串转[]byte：var bytes = []byte(“hello go”) 123//字符串转[]byte：var bytes = []byte(&quot;hello go&quot;)var bytes = []byte(&quot;hello go&quot;)fmt.Printf(&quot;bytes=%v\\n&quot;,bytes) ​ 6. 等等等！！！！ 错误处理代码演示12345678910111213141516171819202122package mainimport &quot;fmt&quot;func test() &#123; //使用defer+recover 来捕获和处理异常 defer func() &#123; err := recover()//recover内置函数，可以捕获到异常 if err != nil &#123; //说明捕获到错误 fmt.Println(&quot;err：&quot;,err) &#125; &#125;() n1 := 10 n2 := 0 //被除数不能为0，抛出异常 res := n1 / n2 fmt.Println(&quot;res=&quot;, res)&#125;func main() &#123; test() fmt.Println(&quot;main下面的代码...&quot;)&#125; defer数据类型数组数组是值类型如何定义数组​ var 变量名 [数组长度]数组类型 ​ 例：var array [10]int 数组如何初始化1231. array = [10]int&#123;1,2,3,4,5,6,7,8,12,22&#125;2. array = [...]int&#123;1,2,3,4,5&#125; //...表示数组的长度为动态3. array = [...]int[1:3,4:3] //表示下标为1的值为3 下标为4的值为3 多维数组二维数组在内存中的布局： 二维数组使用方式（1）12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;//多维数组func main() &#123; //输出下面数字格式 /* 0 0 0 0 0 0 0 0 1 0 0 0 0 2 0 3 0 0 0 0 0 0 0 0 */ var arr [4][6]int arr[1][2] = 1 arr[2][1] = 2 arr[2][3] = 3 for i := 0; i &lt; 4; i++ &#123; for j := 0; j &lt; 6; j++ &#123; fmt.Print(arr[i][j], &quot; &quot;) &#125; fmt.Println() &#125;&#125; 二维数组使用方式（2）（直接初始化）12var arr1 [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125; fmt.Println(arr1) 二维数组的遍历1234567891011121314151617var arr1 [2][3]int = [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; //用for遍历 for i := 0; i &lt; len(arr1); i++ &#123; for j := 0; j &lt; len(arr1[i]); j++ &#123; fmt.Printf(&quot;%v\\t&quot;, arr1[i][j]) &#125; fmt.Println() &#125; //用for-range遍历 for i, v := range arr1 &#123; for j, v2 := range v &#123; fmt.Printf(&quot;arr[%v][%v] = %v&quot;,j,i,v2) &#125; fmt.Println() &#125; 注意：&ensp;&ensp;&ensp;&ensp;多维数组只有第一层 可以使用...来让编译器推导数组长度。例如 ↓ 123456789101112//支持的写法a := [...][2]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,&#125;//不支持多维数组的内层使用...b := [3][...]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,&#125; 切片切片是引用类型切片的本质​ 切片就是一个框，框住了一块连续的内存 ​ 切片属于引用类型 ，真正的数据都是保存在底层数组里面的 ​ 三个元素：指针 长度 容量 切片的扩容 ​ 如果申请的容量大于原来的2倍，那就直接扩容之新申请的容量 ​ 如果小于1024，那么就直接两倍 ​ 如果大于1024，那就按照1.25倍去扩容 ​ 具体存储的值类型不同，扩容策略也有细微的改变 切片不能直接比较​ a1 := []int //a1 == nil ​ a2 := []int{} //a1 != nil ​ 要判断一个切片是否为空，应该用len(s) == 0 ，不应该使用 s == nil 来判断！ 切片（slice）（案例）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport &quot;fmt&quot;func main() &#123; //定义切片 var s1 []int //定义一个int类型的切片 var s2 []string //定义一个string类型的切片 fmt.Println(s1, s2) fmt.Println(s1 == nil) //true fmt.Println(s2 == nil) //true //初始化 s1 = []int&#123;1, 2, 3&#125; s2 = []string&#123;&quot;哈哈&quot;, &quot;呵呵&quot;, &quot;干干&quot;&#125; fmt.Println(s1, s2) fmt.Println(s1 == nil) //true fmt.Println(s2 == nil) //true //长度和容量 fmt.Printf(&quot;len(s1):%d cap(s1):%d\\n&quot;, len(s1), cap(s1)) fmt.Printf(&quot;len(s2):%d cap(s2):%d\\n&quot;, len(s2), cap(s2)) //由数组得到切片 a1 := [...]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; s3 := a1[0:4] //基于一个数组切割，左包含右不包含 ，（左闭又开） fmt.Println(s3) s4 := a1[:5] // [0:5] fmt.Println(s4) s5 := a1[4:] //[4:len(a1)] fmt.Println(s5) s6 := a1[:] //[0:len(a1)] fmt.Println(s6) //切片的容量是指底层数组的容量 fmt.Printf(&quot;len(s4):%d cap(s4):%d\\n&quot;, len(s4), cap(s4)) fmt.Printf(&quot;len(s5):%d cap(s5):%d\\n&quot;, len(s5), cap(s5)) //切片再切割 s7 := s5[4:] //[9] fmt.Printf(&quot;len(s7):%d cap(s7):%d\\n&quot;, len(s7), cap(s7)) //切片是引用传递,都指向了底层的数组 fmt.Println(&quot;s5:&quot;, s5) a1[8] = 900 //修改了底层数组的值 fmt.Println(&quot;s5:&quot;, s5) fmt.Println(&quot;s4:&quot;, s4) fmt.Println(&quot;s7:&quot;, s7)&#125; make123456//make定义切片s1 := make([]int,5,10) //male(数据类型，长度，容量)fmt.Printf(&quot;s1=%v lent(s1)=%d cap(s1)=%d\\n&quot;,s1,len(s1),cap(s1))s2 := make([]int,0,10) //male(数据类型，长度，容量)fmt.Printf(&quot;s2=%v lent(s2)=%d cap(s2)=%d\\n&quot;,s2,len(s2),cap(s2)) 切片的遍历12345678910//切片的遍历s3 := []int&#123;1, 3, 4&#125;//1.索引遍历for i := 0; i &lt; len(s3); i++ &#123; fmt.Println(s3[i])&#125;//2.for rabge循环for i,v:=range s3&#123; fmt.Println(i,v)&#125; append123456789101112131415161718192021package mainimport &quot;fmt&quot;//append（）为切片追加元素func main() &#123; s1 := []string&#123;&quot;哈哈&quot;,&quot;呵呵&quot;,&quot;干干&quot;&#125; fmt.Printf(&quot;s1=%v lent(s1)=%d cap(s1)=%d\\n&quot;, s1, len(s1), cap(s1)) //s1[3] = &quot;啪啪&quot; //错误的写法，会导致编译错误 ，索引越界！！！ //调用append函数必须用原来的切片变量接收返回值 //append追加元素，原来的底层数组放不下的时候，Go底层就会把底层数组换一个 s1 = append(s1,&quot;啪啪&quot;) fmt.Printf(&quot;s1=%v lent(s1)=%d cap(s1)=%d\\n&quot;, s1, len(s1), cap(s1)) s1 = append(s1,&quot;哥哥&quot;,&quot;嗷嗷&quot;) fmt.Printf(&quot;s1=%v lent(s1)=%d cap(s1)=%d\\n&quot;, s1, len(s1), cap(s1)) ss := []string&#123;&quot;昳跌&quot;,&quot;妈妈&quot;&#125; s1 = append(s1,ss...) //表示拆开 fmt.Printf(&quot;s1=%v lent(s1)=%d cap(s1)=%d\\n&quot;, s1, len(s1), cap(s1))&#125; copy1234567891011121314151617package mainimport &quot;fmt&quot;//copyfunc main() &#123; a1 := []int&#123;1,2,3&#125; a2 := a1 var a3 = make([]int,3,3) copy(a3,a1) //使用capy（）函数，将a1中的元素赋值给a3 fmt.Println(&quot;\\n&quot;,a1,a2,a3) a1[0] = 100 fmt.Println(a1,a2,a3)&#125; 删除切片中的指定元素12345678910111213//删除切片中的元素x1 := [...]int&#123;1,2,3&#125; //定义数组s2 := x1[:] //切片赋值fmt.Println(s2,len(s2),cap(s2))//1.切片不保留具体的值 2.切片对应底层的数组 3.底层数组都是占用一块连续的内存fmt.Printf(&quot;%p\\n&quot;,&amp;s2[0])s2 = append(s2[:1],s2[2:]...) //修改底层数组fmt.Printf(&quot;%p\\n&quot;,&amp;s2[0])fmt.Println(s2,len(s2),cap(s2))fmt.Println(x1) _string 与 slice1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; str1 := &quot;hello@liuyang&quot; //如果需要修改字符串，可以先将string-&gt;[]byte 或者 []rune-&gt;修改 -&gt; 重写之后再转成string //hello@liuyang 改成 aello@liuyang str2 := []byte(str1) str2[0] = &#x27;a&#x27; str1 = string(str2) fmt.Println(str1) //细节 转成byte[]后，可以处理英文或者数字，不能处理中文 //原因 byte[]是按字节来处理，而一个汉字是三个字节，所以就会乱码 //解决：将string转成[]rune即可，因为[]rune是按字符来处理，兼容汉字 str3 := []rune(str1) str3[0] = &#x27;北&#x27; str1 = string(str3) fmt.Println(str1)&#125; 指针​ Go语言中不存在指针操作，只需要记住两个符号： ​ 1.&amp;：取地址符 ​ 2. *：根据地址取值 123456a := 8//1.&amp;取地址符b := &amp;a //把8所在内存中的地址赋值给bfmt.Println(b)//2.*根据地址取内存中对应的值fmt.Println(*b) map序言1231. Go语言中提供的映射关系容器是`map`，其内部使用`散列表(hash)`来实现的2. map是一种**无序** 的基于`key-value`的数据结构。3. Go语言中的map是**引用类型** ，**必须初始化（也就是分配内存）才能使用** 。 map案例12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;func main() &#123; var m1 map[string]int fmt.Println(m1 == nil) //还没有初始化（没有在内存汇总开辟空间） m1 = make(map[string]int, 10) //要估算好map容量，避免在运行中动态扩容 m1[&quot;嘎嘎&quot;] = 18 m1[&quot;屁屁&quot;] = 14 fmt.Println(m1) fmt.Println(m1[&quot;屁屁&quot;]) fmt.Println(m1[&quot;伽伽&quot;]) //如果不存在这个key，则返回这个类型的零值 value, ok := m1[&quot;伽伽&quot;] if !ok &#123; fmt.Println(&quot;查无此人&quot;) &#125; else &#123; fmt.Println(value) &#125;&#125;**/* 代码说明： 1.map在使用前一定要make 2.map的key是不能重复，如果重复了，则以最后这个key-value为准 3.map的value是可以相同的 4.map的key-value是无序的*/ ** map的使用方式（3种）1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;//map的使用func main() &#123; **//第一种** var a map[string]string a = make(map[string]string,10) a[&quot;no1&quot;] = &quot;哈哈&quot; a[&quot;no2&quot;] = &quot;呵呵&quot; fmt.Println(a) ** ** **//第二种** var b map[string]string b = make(map[string]string) b[&quot;no3&quot;] = &quot;哥哥&quot; b[&quot;no4&quot;] = &quot;弟弟&quot; fmt.Println(b) **//第三种** c := map[string]string&#123; &quot;no5&quot; : &quot;张飞&quot;, &quot;no6&quot; : &quot;关羽&quot;, &#125; fmt.Println(c)&#125; map的遍历12345678910111213//map的遍历//1.键值都遍历 for k, v := range m1 &#123; fmt.Println(k, v) &#125; //2.只遍历key for k := range m1 &#123; fmt.Println(k) &#125; //3.值遍历value for _, v := range m1 &#123; fmt.Println(v) &#125; map的crud操作1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;//map的crud操作func main() &#123; //map的添加和修改 var a map[string]string a = make(map[string]string) a[&quot;no1&quot;] = &quot;哈哈&quot; a[&quot;no2&quot;] = &quot;呵呵&quot; //增加，因为不存在[&quot;no3&quot;]这个键，所以会增加这个键 a[&quot;no3&quot;] = &quot;干干&quot; fmt.Println(a) //修改，因为存在[&quot;no3&quot;]这个键，所以会修改这个键 a[&quot;no3&quot;] = &quot;啪啪&quot; fmt.Println(a) //删除 delete(a,&quot;no3&quot;) fmt.Println(a) //删除一个不存在的key时，删除不会操作，也不会报错 delete(a,&quot;no9&quot;) fmt.Println(a) //如果希望一次性删除所有的key //1.遍历所有的key，逐一删除[遍历] //2.直接make一个新的空间 a = make(map[string]string) fmt.Println(a) //查找 val,ok := a[&quot;no8&quot;] if ok &#123; fmt.Printf(&quot;找到了=%v&quot;,val) &#125;else &#123; fmt.Printf(&quot;没找到&quot;) &#125;&#125; map切片定义： &ensp;&ensp;&ensp;&ensp;切片的类型如果是map，则我们成为slice of map切片，这样使用则map个数就可以动态变化了。 案例： 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport &quot;fmt&quot;//slice of mapfunc main() &#123; //演示map切片使用 /* 要求：使用一个map来记录monster的信息name和age，也就是说一个monster对应一个map，并且妖怪的数量可以动态增加=》map切片 */ //1,声明map切片 var monster []map[string]string monster = make([]map[string]string,2) //计划放入两个妖怪 //2.增加一个妖怪的信息 if monster[0] == nil&#123; monster[0] = make(map[string]string,2) monster[0][&quot;name&quot;] = &quot;哈哈&quot; monster[0][&quot;age&quot;] = &quot;23&quot; &#125; if monster[1] == nil&#123; monster[1] = make(map[string]string,2) monster[1][&quot;name&quot;] = &quot;嘎嘎&quot; monster[1][&quot;age&quot;] = &quot;19&quot; &#125; //下面这个写法越界，因为切片长度为2 //if monster[2] == nil&#123; // monster[2] = make(map[string]string,2) // monster[2][&quot;name&quot;] = &quot;嘎嘎&quot; // monster[2][&quot;age&quot;] = &quot;19&quot; //&#125; newMonster := map[string]string&#123; &quot;name&quot;:&quot;渣渣&quot;, &quot;age&quot;:&quot;43&quot;, &#125; monster = append(monster,newMonster)//用append来动态追加 fmt.Println(monster)&#125; map排序案例： 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;sort&quot;)//map排序func main() &#123; maps := make(map[int]int,10) maps[4] = 10 maps[8] = 8 maps[3] = 2 maps[9] = 5 fmt.Println(maps)//新版本默认为升序,教学视频中的go版本较老，老版本的Go中，map默认为无序 //如果按照map的key的顺序进行排序输出 //1.先将map放进切片里 //2.对切片进行排序 //3.遍历切片，然后按照key来输出map的值 var keys []int for k,_ := range maps &#123; keys = append(keys,k) &#125; sort.Ints(keys) fmt.Println(keys) for _,v := range keys&#123; fmt.Printf(&quot;map[%v]=%v\\n&quot;,v,maps[v]) &#125;&#125; 元素类型为map和slice组合12345678910//元素为map类型的切片var s1 = make([]map[int]string,10,10)s1[0] = make(map[int]string ,1) //切记map类型需要初始化后才能使用,也就是在内存开辟空间s1[0][2] = &quot;嘎嘎&quot;fmt.Println(s1)//元素为切片类型的mapvar m1 = make(map[string][]int,10)m1[&quot;哈哈&quot;] = []int&#123;1,2,3,4&#125;fmt.Println(m1) make和new的区别1231. `make`和`new`都是用来申请内存的。2. `new`很少用,一般用来给基本数据类型申请内存,`string`，`int` ，返回的是对应的类型指针（`*string` , `*int`）3. `make`是用来给`slice`,`map`,`chan`来申请内存的，make函数返回的是对应的这三个类型的本身。 排序和查找&ensp;&ensp;&ensp;&ensp;#### 排序 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;定义： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;排序是将一组数据，依指定的顺序进行排序 ​ 排序的种类类： &ensp;&ensp;&ensp;&ensp;1. 内部排序法： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 指将需要处理的所有数据都加载到内存储存器中进行排序。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 包括：交换式排序法，选择式排序法 ，插入式排序法 &ensp;&ensp;&ensp;&ensp;2. 外部排序法 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 包括：合并排序法 ，直接合并排序法 &ensp;&ensp;&ensp;&ensp;#### 查找： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;定义： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;就是查找 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;查找的种类： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1. 顺序查找 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2. 二分查找 自定义类型和类型别名12345678910111213//type后面跟的是类型type myInt int //自定义类型（一直有效）type youInt = int //类型别名（只在敲代码过程中有效，编译（build）之后无效）func main() &#123; var n myInt n = 100 fmt.Printf(&quot;%T\\n&quot;,n) var m youInt m = 200 fmt.Printf(&quot;%T\\n&quot;,m)&#125; 结构体结构体是值类型结构体与结构体变量（实例/对象）的关系示意图 对上图的说明和总结： &ensp;&ensp;&ensp;&ensp;1. 将一类事物的特征提取出来（比如猫类），形成一个新的数据类型，就是一个结构体。 &ensp;&ensp;&ensp;&ensp;2. 通过这个结构体，我们可以创建多个变量（实例/对象） &ensp;&ensp;&ensp;&ensp;3. 事物可以是任意类（猫类，人类，鱼类……） 示例：1234567891011121314151617181920package mainimport &quot;fmt&quot;//结构体type person struct &#123; name string age int hobby []string&#125;//主函数func main() &#123; var p person p.name = &quot;刘阳&quot; p.age = 24 p.hobby = []string&#123;&quot;LOL&quot;,&quot;足球&quot;&#125; fmt.Println(p) //&#123;刘阳 24 [LOL 足球]&#125; fmt.Println(p.name) //刘阳&#125; 结构体和结构体变量（示例）的区别和联系 结构体是自定义数据类型，代表一类事物 结构体变量（实例）是具体的，实际的，代表一个具体的变量 结构体变量（实例）在内存的布局（重要！） 调用结构体方式（4种）123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;type Persion struct &#123; Name string Age int&#125;//四种调用结构体变量的方式func main() &#123; //第一种 var p Persion p.Name = &quot;哈哈&quot; //第二种 p := Persion&#123;&quot;呵呵&quot;,23&#125; //第三种 var p *Persion = new(Persion) p.Name = &quot;哈哈&quot; //两种方式赋值 (*p).Name = &quot;法法&quot; //两种方式赋值 //第四种 //var p *Persion = &amp;Persion&#123;&quot;哈哈&quot;,23&#125;//也可以这种方式赋值 var p *Persion = &amp;Persion&#123;&#125; (*p).Name = &quot;法法&quot;//也可以这种方式赋值 p.Name = &quot;嘎嘎&quot;//也可以这种方式赋值&#125; Tag标签（json序列化）123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type A struct &#123; Num int&#125;type B struct &#123; Num int&#125;type Monster struct&#123; Name string `json:&quot;name&quot;` //`json:&quot;name&quot;` 就是struct的tag Age int `json:&quot;age&quot;` Skill string `json:&quot;skill&quot;`&#125;func main() &#123; var a A var b B a = A(b) //可以强转，但是必须是结构体的字段要完全一样 fmt.Println(a,b) //创建monster变量 Monster := Monster&#123;&quot;牛魔王&quot;,299,&quot;芭蕉扇！&quot;&#125; //将Monster变量序列化为json //json.Marshal 函数中使用了反射 jsonStr,err := json.Marshal(Monster) if err != nil&#123; fmt.Println(&quot;json数据处理错误&quot;,err) &#125; fmt.Println(string(jsonStr))&#125; func方法的声明和调用：123456789101112type A struct&#123; Num int&#125; func (a A)test()&#123; fmt.Println(a.Num)&#125; **/* 对上面代码解读： 1.func（a A）test（）&#123;&#125; 表示A结构体有一方法，方法名为test 2.（a A）提现test方法是和A类型绑定的*/ ** 示例：1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type Person struct &#123; Num int&#125;func (a Person) test() &#123; fmt.Println(a.Num)&#125;func main() &#123; var p Person p.Num = 23 p.test()&#125;**/* 总结： 1.test方法和Person结构体绑定 2.test方法只能通过Person类型的变量调用，而不能直接调用，也不能使用其他类型变量来调用 3.func (p Person) test()&#123;&#125;...p表示哪个Person变量调用，这个p就是它的副本，这点和 函数传参非常相似 4.p这个变量名可以自定义*/** 方法和函数的区别&ensp;&ensp;&ensp;&ensp;1. 调用方式不一样： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;函数调用方式：函数名（实参） &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;方法调用方式：变量.方法名（实参） &ensp;&ensp;&ensp;&ensp; 2. 对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递，反之亦然 &ensp;&ensp;&ensp;&ensp; 3. 杜天宇方法（如struct），接受者为值类型时，可以直接用指针类型的变量调用方法，反过来同样可以 工厂模式&ensp;&ensp;&ensp;&ensp;### 说明： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;Golang的结构体中没有构造函数 ，通常可以使用工厂模式 来解决。 &ensp;&ensp;&ensp;&ensp;### 示例： 面向对象编程思想抽象介绍：&ensp;&ensp;&ensp;&ensp;我们定义结构体的时候，实际上就是把一类事物的共有的属性（字段）和行为（方法）提取出来，形成一个物理模型（结构体）。这种研究问题的方法称为抽象。 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport &quot;fmt&quot;type Account struct &#123; AccountNo string Pwd int Balance float64&#125;//存款func (account *Account) saveMoney(money float64, pwd int) &#123; if pwd != account.Pwd &#123; fmt.Println(&quot;密码不正确&quot;) &#125; else if money &lt;= 0 &#123; fmt.Println(&quot;余额错误&quot;) &#125; else &#123; account.Balance += money fmt.Println(&quot;存款成功&quot;) &#125;&#125;//取款func (account *Account) withdrawle(money float64, pwd int) &#123; if pwd != account.Pwd &#123; fmt.Println(&quot;密码不正确&quot;) &#125; else if money &lt;= 0 || money &gt; account.Balance&#123; fmt.Println(&quot;取款金额错误&quot;) &#125; else &#123; account.Balance -= money fmt.Println(&quot;取款成功&quot;) &#125;&#125;// Query 查询func (account *Account) Query(pwd int) &#123; if pwd != account.Pwd &#123; fmt.Println(&quot;密码不正确&quot;) &#125;else &#123; fmt.Printf(&quot;账号为:%v 余额为:%v&quot;,account.AccountNo,account.Balance) &#125;&#125;func main() &#123; //赋值 account := Account&#123; AccountNo: &quot;fs33333&quot;, Pwd: 666666, Balance: 89.38, &#125; account.Query(666666) account.saveMoney(23,666666) account.Query(666666) account.withdrawle(12,666666) account.Query(666666)&#125; 封装：示例： 继承&ensp;&ensp;&ensp;&ensp;#### 嵌套匿名结构体的基本语法： 123456789type Goods struct&#123; Name string Price int&#125;type Book struct&#123; Goods Writer string&#125; 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport &quot;fmt&quot;//学生考试系统type student struct &#123; Name string Age int Score int&#125;// Pupil 小学生type Pupil struct &#123; student //嵌入匿名结构体&#125;// Graduate 大学生type Graduate struct &#123; student //嵌入匿名结构体&#125;//将Pupil和Graduate 共有的方法也绑定到 *studentfunc (s *student) showInfo() &#123; fmt.Printf(&quot;名字：%v 年龄:%v 分数:%v&quot;, s.Name, s.Age, s.Score)&#125;func (s *student) setScore(score int) &#123; s.Score = score&#125;//这是Pupil特有方法，保留func (p *Pupil) testing() &#123; fmt.Println(&quot;小学生正在考试中...&quot;)&#125;//这是Graduate特有方法，保留func (p *Graduate) testing() &#123; fmt.Println(&quot;大学生正在考试中...&quot;)&#125;func main() &#123; pupil := &amp;Pupil&#123;&#125; pupil.student.Name = &quot;刘阳&quot; pupil.student.Age = 11 pupil.testing() pupil.setScore(89) pupil.showInfo() graduate := &amp;Graduate&#123;&#125; graduate.student.Name = &quot;大刘阳&quot; graduate.student.Age = 20 graduate.testing() graduate.setScore(190) graduate.showInfo()&#125; 多重继承 继承的深入讨论： 结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段，方法，都可以用。【举例说明】 匿名结构体字段访问可以简化 123456789101112var b B b.A.Name = &quot;李阳&quot; b.A.age = 29 b.A.SayOk() b.A.hello() //上面的的写法可以简写： b.Name = &quot;刘阳&quot; b.age = 11 b.SayOk() b.hello() 当结构体和匿名结构体有相同的字段或者方法时，编辑器采用就近访问原则访问。 结构体嵌入两个（或多个）匿名结构体，如两个匿名结构体有相同的字段和方法（同时结构体本身没有 同名的字段和方法），在访问时，就必须明确指定匿名结构体的名字，否则编译报错 如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构 体的字段或者方法时，就必须带上结构体的名字。 【举例说明】 多态基本介绍12变量（示例）具有多种形态，面向对象的第三大特征，在Go语言中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。 接口体现多态的两种形式：12345**1.多态参数** ： 在前面的Usb接口的案例中， Usb usb既可以接收手机变量，又可以接收相机变量，就体现了Usb接口的多态。**2.多态数组** ： 给Usb数组中，存放Phone结构体 和 Camera结构体变量 [【示例】](https://www.wolai.com/hPPYLStBT1MwGBxbA7s2Li)。 类型断言基本介绍1类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言。 12345678910111213141516171819202122232425262728//类型断言案例02 var x interface&#123;&#125; var b2 float32 = 1.1 x = b2 //x是空接口，可以接收任何变量 // x=&gt;float32【使用类型断言】 y := x.(float32) fmt.Println(y)/* 案例02代码说明： 1.在进行接口类型断言时，如果类型不匹配，就会报panic，因此进行类型断言时，要确保原来的空接口指向的就是 断言的类型。*/ //类型断言案例03(带检测） var x interface&#123;&#125; var b2 float32 = 1.1 x = b2 //x是空接口，可以接收任何变量 // x=&gt;float32【使用类型断言】 y, ok := x.(float64) if ok &#123; fmt.Println(y) &#125;else &#123; fmt.Println(&quot;断言失败&quot;) &#125; fmt.Println(&quot;代码继续执行&quot;) 接口基本介绍：123interface类型可以定义一组方法，但是这些不需要实现，并且interface不能包含任何变量。到某个自定义类型（比如结构体Phone）要使用的时候，再根据具体情况吧这些方法写出来（实现）。Interface类型默认是一个指针，也就是**引用类型 ** 基本语法 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport &quot;fmt&quot;type Usb interface &#123; Start() Stop()&#125;type Phone struct &#123;&#125;type Camera struct &#123;&#125;// Start 让Phone实现Usb接口的方法func (p Phone) Start()&#123; fmt.Println(&quot;手机开始工作&quot;)&#125;func (p Phone) Stop()&#123; fmt.Println(&quot;手机停止工作&quot;)&#125;// Start 让Camera实现Usb接口的方法func (p Camera) Start()&#123; fmt.Println(&quot;相机开始工作&quot;)&#125;func (p Camera) Stop()&#123; fmt.Println(&quot;相机停止工作&quot;)&#125;// Computer 计算机type Computer struct &#123;&#125;// Working 编写一个Working方法，接收一个Usb接口类型变量//只要是实现了Usb接口，（所谓实现接口，就是指实现了Usb接口声明的所有方法 ）func (c Computer) Working(usb Usb)&#123; //通过Usb接口变量来调用Start和Stop方法 usb.Start() usb.Stop()&#125;func main() &#123; //创建结构体变量 computer := Computer&#123;&#125; phone := Phone&#123;&#125; camera := Camera&#123;&#125; computer.Working(phone) computer.Working(camera)&#125; 说明：12345**1.接口里面所有的方法都没有方法体，即接口里面的方法都是没有实现的方法，接口体现了程序涉及的** **多态** **和** **高 内聚低耦合** **的思想** **2.Golang中的接口，不需要** **显式的实现** **。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这 个接口，因此，Golang中没有implete这样的关键字 ** 注意事项和细节：1234567891011121314151617**1** .接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）[【示例】](https://www.wolai.com/ky6AJDDahGFRxGRQkpWTGv)[](https://www.wolai.com/ky6AJDDahGFRxGRQkpWTGv)**2** .接口中所有的方法都没有方法体，即都是没有实现的方法。 **3** .在Golang中 ，一个自定义类型需要将某个接口的所有方法都实现，我们才能说这个自定义类型实现了该接口。**4** .只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。[【示例】](https://www.wolai.com/ky6AJDDahGFRxGRQkpWTGv)**5** . 一个自定义类型可以实现多个接口[【示例】 ](https://www.wolai.com/ky6AJDDahGFRxGRQkpWTGv)**6** . Golang中接口不能有任何变量。 **7** . 一个接口（比如A接口）可以继承多个别的接口（比如B，C接口），这时如果要实现A接口，也必须将B,C的接 口的方法也全部实现【示例】 **8** . 空接口的interface&#123;&#125;没有任何的方法，所以所有类型都实现了空接口，所有我们可以把任何一个变量赋值给空 接口 接口VS继承示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport &quot;fmt&quot;type BirdAble interface &#123; Flying()&#125;type FishAble interface &#123; Swimming()&#125;// Monkey Monkey结构体type Monkey struct &#123; Name string&#125;type LittleMonkey struct &#123; Monkey&#125;func (m *Monkey) climbing()&#123; fmt.Println(m.Name,&quot;生来会爬树&quot;)&#125;func (lm *LittleMonkey) Flying()&#123; fmt.Println(lm.Name,&quot;会飞了&quot;)&#125;func (lm *LittleMonkey) Swimming()&#123; fmt.Println(lm.Name,&quot;会游泳了&quot;)&#125;func main() &#123; mon := LittleMonkey&#123;Monkey&#123; Name: &quot;悟空&quot;, &#125;&#125; mon.climbing() mon.Flying() mon.Swimming()&#125;/* **代码总结： 1.当A结构体继承了B结构体，那么A结构体就自动继承了B结构体的字段和方法，并且可以直接使用。 2.当A结构体需要拓展功能，同时不希望破坏继承关系，则可以去实现某个接口即可，因此我们可以认为：实现接口 是对继承机制的补充。** */ 接口与继承的区别：123456781.接口和继承解决的问题不同 继承的价值主要在于：解决代码的复用性和可维护性。 接口的价值主要在于：设计，设计好各种规范（方法），让其他自定义类型去实现这些方法。 2.接口比继承更加灵活 接口比继承更加灵活，继承是满足is-a的关系，而接口只需要满足like-a的关系。 3.接口在一定程度上可以实现代码解耦。 文件基本介绍文件在程序中是以流的形式来操作的（指针类型） 流： 数据在数据源（文件）和程序（内存）之间经历的路程 输入流： 数据从数据源（文件）到程序（内存）的路径 输出流： 数据从程序（内存）到数据源（文件）的路径 读写文件操作12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; //打开文件 //概念说明：file的叫法（file对象，file指针，file文件句柄） file , err :=os.Open(&quot;d:/test.txt&quot;) if err != nil&#123; fmt.Println(&quot;open file err=&quot;,err) &#125; //输出文件，看看文件是什么,file就是一个指针 fmt.Printf(&quot;file=%v\\n&quot;, file) //关闭文件 err = file.Close() if err != nil &#123; fmt.Println(&quot;close file err=&quot;,err) &#125;&#125; 读取文件应用实例1234567891011121314151617181920212223242526272829303132333435363738394041/* 读取文件的内容并显示在终端（待缓冲区的方式），*/package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot;)func main() &#123; //打开文件 file, err := os.Open(&quot;d:/test.txt&quot;) if err != nil &#123; fmt.Println(&quot;open file err=&quot;, err) &#125; //当函数退出时，要即使关闭file，否则会有内存泄露。 defer file.Close() //创建一个*Reader ，带缓冲区的 /* cibst( defaultBufSize ) */ reader := bufio.NewReader(file) for &#123; str, err := reader.ReadString(&#x27;\\n&#x27;) if err == io.EOF&#123; break &#125;else &#123; fmt.Print(str) &#125; &#125;&#125; 写入创建文件应用实例123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; //创建一个新文件 //1.打开文件，不存在就创建。 filePath := &quot;d:/test02.txt&quot; file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666) if err != nil &#123; fmt.Println(&quot;open file err=&quot;, err) return &#125; defer file.Close() //准备写入5句 &#x27;hello，Garden&#x27; str := &quot;hello,Garden\\n&quot; //写入时，使用带缓存的 *Writer writer := bufio.NewWriter(file) for i := 0; i &lt; 5; i++ &#123; writer.WriteString(str) &#125; //因为writer是带缓存的，因此调用writerString的时候都是先进缓存的，所以调用Flush方法 //将数据写入到真正的文件中。 writer.Flush()&#125; 命令行参数1234567891011121314151617181920212223242526package mainimport ( &quot;flag&quot; &quot;fmt&quot;)func main() &#123; //定义变量 var name string var pwd string var host string var port string flag.StringVar(&amp;name,&quot;n&quot;,&quot;&quot;,&quot;用户名&quot;) flag.StringVar(&amp;pwd,&quot;pwd&quot;,&quot;&quot;,&quot;密码&quot;) flag.StringVar(&amp;host,&quot;h&quot;,&quot;&quot;,&quot;主机&quot;) flag.StringVar(&amp;port,&quot;p&quot;, &quot;3306&quot;,&quot;端口&quot;) flag.Parse() fmt.Printf(&quot;name=%v pwd=%v host=%v port=%v&quot;,name,pwd,host,port)&#125; 单元测试传统方式测试示例12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;//一个测试函数func addUpper(n int) int &#123; res := 0 for i := 1; i &lt;= n-1; i++ &#123; res += i &#125; return res&#125;func main() &#123; //传统判断方法 res := addUpper(10) if res != 55 &#123; fmt.Printf(&quot;返回值错误。返回：%v 期望：%v&quot;, res, 55) &#125; else &#123; fmt.Printf(&quot;返回值正确。返回：%v 期望：%v&quot;, res, 55) &#125;&#125;**/* 传统测试方式缺点分析： 1.不方便，我们需要在main函数中去调用，这样就需要去修改main函数，如果现在的项目正在运行，就可 能会停止项目 2.不利于管理，因为当我们测试多个函数或者多个模块时，都需要写在main函数，不利于管理和清晰我们思 路。 3.引出单元测试-》testing 测试框架，可以很好的解决以上问题。*/** 基本介绍123456**1.确保函数是可运行的，并且运行结果是正确的。2.确保写出来的代码性能没问题3.单元测试能及时的发现程序设计的或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测 试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定。** 快速入门 快速入门总结12345678910111213141516171819202122231.测试用例文件名必须以_test.go结尾，比如：cail_test.go （cail不是固定的）2.测试用例函数必须以Test开头，一般来说就是Test+被测试函数名，例如：TestAddUpper3.TestAddUpper(t *testing.T)的形参类型必须是*testing.T [【看下手册】](https://studygolang.com/pkgdoc)4.一个测试用例文件中，可以有多个测试用例函数，比如：TestAddUpper、TestGetSub 5.运行测试用例指令 （1）cmd&gt;go test (如果运行正确，无日志。如果有错误，会输出日志) （2）cmd&gt;go test -v （运行正确或者错误，都会输出日志）6. 当出现错误时，可以使用t.Fatalf来格式化输出信息，并退出程序7.t.Logf方法可以输出相应的日志8.PASS表示测试用例运行成功，FAIL表示测试用例运行失败9.测试单个文件，一定要带上被测试的原文件 cmd&gt;go test -v cail_test.go cail.go10. 测试单个方法 cmd&gt;go test -v test.run TestAddUpper 协程（goroutine）案例引出：1234567**需求：要求统计1-9000000000的数字中，哪些数字是素数。** 分析思路：1.传统方法，就是适用一个循环，循环的判断各个数是不是素数。【很慢】2.使用并发或者并行的方式，将统计素数的任务分配给多个goroutine去完成，这时就会用到goroutine。 进程和线程1234567**1.进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位。2.线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。3.一个进程可以创建和销毁多个线程，同一个进程的多个线程可以并发执行。4.一个程序至少有一个进程，一个进程最少有一个线程。 ** 示意图 并发和并行123456789**1.并发：** 多线程程序在单核上运行，就是并发 ex： 因为是在一个cpu上，比如有10个线程，每个线程执行10毫秒（进行轮询操作），丛人的角度看，好像这 10个线程都在运行，但是从微观上看，某一个时间点上看，其实只有一个线程在执行，这就是并发。**2.并行：** 多线程程序在多核上运行，就是并行 ex: 因为是在多个CPU上（比如10个CPU），比如有10个线程，每个线程执行10毫秒（各自在不同的CPU上 执行，无论是从人的角度看，还是从某个时间点来看，都是10个线程在同时执行，这就是并行。 示意图 Go主线程和Go协程12345678**1.Go主线程（有程序员直接称为线程/也可以理解为进程）：一个Go线程上，可以起多个协程，可以理解为协 程是轻量级的线程[编译器做优化] 2.Go协程的特点：** ** (1) 有独立的栈空间 (2) 共享程序堆空间 (3) 调度由用户控制 (4) 协程是轻量级的线程 ** goroutine快速入门案例说明 123456789101112131415161718192021/* ** 1.在主线程（可以理解为进程）中，开启一个goroutine，该协程每隔一秒输出 &quot;hello world&quot; 2.在主线程中也每隔一秒输出 ”hello，golang“，输出10次后，退出程序 3.要求主线程和goroutine同时执行** */func test() &#123; for i := 1; i &lt;= 10; i++ &#123; fmt.Println(&quot;test() hellow world&quot;) time.Sleep(time.Second) &#125;&#125;func main() &#123; go test() for i := 1; i &lt;= 10; i++ &#123; fmt.Println(&quot;main() hellow golang&quot;) time.Sleep(time.Second) &#125;&#125; 画出主线程和协程执行流程图 快速入门小结123456**1.主线程是一个物理线程，直接作用在cpu上的。是重量级的，非常耗费cpu资源。2.协程从主线程开启的，是轻量级线程，是逻辑态，对资源消耗相对小3.Golang的协程机制是重要特点，可以轻松开启上万个协程，其他编程语言的并发机制一般是基于线程的，开 启过多线程，资源耗费大，这里就凸显出Golang在并发上的优势了。 ** gouortine的调度模式&ensp;&ensp;&ensp;&ensp;MPG模式基本介绍 &ensp;&ensp;&ensp;&ensp;MPG模式运行的状态0 1 &ensp;&ensp;&ensp;&ensp;#### MPG模式运行的状态0 2 设置Golang运行的cpu数123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; cpuNum := runtime.NumCPU() fmt.Println(cpuNum) runtime.GOMAXPROCS(cpuNum - 1) fmt.Println(&quot;ok&quot;)&#125;/* **go1.8后，默认让程序运行在多个CPU上，可以不用设置了。 go1.8前，还是要设置一下，可以更高效的利用CPU** */ 管道（channel）看个需求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* **需求： 现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中。最后显示出来。 要求使用goroutine完成 实现思路： 1.编写一个函数，来计算各个数的阶乘，并放入到map中 2.我们启动的协程多个，将统计的结果放入到map中 3.map应该做出一个全局的。** */package mainimport ( &quot;fmt&quot; &quot;time&quot;)var myMap = make(map[int]int, 10)//test函数就是计算n!，将这个结果放入到map中func test(n int) &#123; res := 1 for i := 1; i &lt;= 200; i++ &#123; res *= i &#125; //将res 放到map里 myMap[n] = res //报错：fatal error: concurrent map writes&#125;func main() &#123; //我们这里开多个协程完成这个任务【200个】 for i := 1;i&lt;= 200;i++&#123; go test(i) &#125; //休眠10秒钟 time.Sleep(time.Second * 10) //输出结果 for i,v := range myMap&#123; fmt.Printf(&quot;map[%v]%v&quot;,i,v) &#125;&#125;/* ** ** **代码问题： 上面代码存在资源竞争问题，在运行程序时，如何知道是否存在资源竞争问题？很简单，在编译该程序时，增 加一个参数，-race即可 【下面示意图】** */ 不同goroutine之间如何通讯&ensp;&ensp;&ensp;&ensp;1. ** 全局变量互斥锁** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667**//因为上面代码没有对全局变量m加锁，因此会出现资源争夺问题，代码会出现错误，提示concurrent map writes//解决方案：加入互斥锁//我们的数的阶乘很大，结果会越界，可以将求阶乘改为sum += uint64（i）//代码改进：↓ ↓ ↓** package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)/* 需求： 现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中。最后显示出来。 要求使用goroutine完成 思路： 1.编写一个函数，来计算各个数的阶乘，并放入到map中 2.我们启动的协程多个，将统计的结果放入到map中 3.map应该做出一个全局的。*/var ( myMap = make(map[int]int, 10) //lock是一个全局的互斥锁 //sync 是包：synchornized 同步 //Mutex:是互斥 lock sync.Mutex)//test函数就是计算n!，将这个结果放入到map中func test(n int) &#123; res := 1 for i := 1; i &lt;= n; i++ &#123; res *= i &#125; //将res 放到map里 并 加锁 lock.Lock() myMap[n] = res //报错：fatal error: concurrent map writes //解锁 lock.Unlock()&#125;func main() &#123; //我们这里开多个协程完成这个任务【200个】 for i := 1;i&lt;= 20;i++&#123; go test(i) &#125; //休眠10秒钟 time.Sleep(time.Second * 5) //输出结果 lock.Lock() for i,v := range myMap&#123; fmt.Printf(&quot;map[%d]%d\\n&quot;,i,v) &#125; lock.Unlock()&#125; &ensp;&ensp;&ensp;&ensp;2. 使用管道（channel） &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;为什么需要channel 123456**1.主线程在等待所有goroutine全部完成的时间很难确定，我们这里设置了5秒，仅仅是估算。** **2.如果主线程休眠时间长了，会加长等待时间，如果等待时间短了，可能还有goroutine处于工作状 态，这时也会随主线程的退出而销毁** **3.通过全局加锁同步来时间通讯，也并不利于多个协程对全局变量的读写操作。 ** channel基本介绍12345678910111.**channel是** **引用类型** **** 2.channel必须初始化才能写入数据，即必须make后才能使用3.channel 本质就是一个数据结构 —— 队列 【见图1.0】4.数据是先进先出的【FIFO：first in first out】5.线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的6.channel是需要指定类型的。例: 一个string 的channel只能存放string的数据 图 1.0 定义/声明channel1234567var 变量名 chan 数据类型例：var intChan chan int （intChan用于存放int类型的数据）var mapChan chan map[int][string] （mapChan用于存放map[int][string]类型的数据var perChan chan Personvar perChan2 chan *Person channel的基本操作、注意事项123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;func main() &#123; //演示channel的使用 //1.创建一个可以容量为3的int类型的channel var intChan chan int intChan = make(chan int,3) //2.看看intChan是什么 fmt.Printf(&quot;intChan 的值：%v intChan本身的地址=%p\\n&quot;,intChan,&amp;intChan) //3.像管道写入数据 intChan &lt;- 10 num := 100 intChan &lt;- num intChan &lt;- 50 //intChan &lt;- 80 //注意：当我们给管道写入数据时，不能超过其容量 //4.看看管道的长度和容量 fmt.Printf(&quot;channel len=%v cap=%v&quot;,len(intChan),cap(intChan)) //5.从channel中取出数据 num2 := &lt;- intChan fmt.Printf(&quot;num = %v&quot;,num2) fmt.Printf(&quot;channel len=%v cap=%v&quot;,len(intChan),cap(intChan)) //6.在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报deadlock num3 := &lt;- intChan num4 := &lt;- intChan num5 := &lt;- intChan //此行报错：deadlock fmt.Println(&quot;num3 = &quot;,num3,&quot;num4 = &quot;,num4,&quot;num5 = &quot;,num5)&#125; channel注意事项12345671.channel中只能存放指定的数据类型2.channel中数据存满就不能再存放了3.如果channel中取出数据后，可以继续放入4.在没有使用协程的情况下，如果channel数据取完了，再取，就会报dead lock（死锁） channel关闭12使用内置函数close可以关闭channel，当channel关闭后，就不能再像channel写数据了，但仍然可以从channel中取数据。 channel的遍历1231.在遍历时，如果channel没有关闭，也会出现deadlock的错误2.在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历 channle和goroutine结合使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950**/* 题目： 请完成goroutine和channel协同工作的具体案例，要求如下： 1.开启一个writeChan协程，向intChan中写入50个整数 2.开启一个readData协程，从管道intChan中读取writeChan写入的数据 3.注意：writeData 和 readData 操作的是同一个管道 4.主线程需要等待writeData和readData协程都完成工作才能退出【管道】*/** package mainimport ( &quot;fmt&quot;)func WriteData(intChan chan int) &#123; for i := 1; i &lt;= 50; i++ &#123; intChan &lt;- i fmt.Printf(&quot;写入:%v\\n&quot;,i) &#125; close(intChan) //写入完毕关闭管道&#125;func ReadData(intChan chan int, exitChan chan bool) &#123; for &#123; v, ok := &lt;-intChan if !ok &#123; break &#125; fmt.Printf(&quot;读到=%v\\n&quot;, v) &#125; //读取完数据以后，即任务完成 exitChan &lt;- true close(exitChan)&#125;func main() &#123; intChan := make(chan int, 50) exitChan := make(chan bool, 1) go WriteData(intChan) go ReadData(intChan, exitChan) for &#123; _ , ok := &lt;-exitChan if !ok&#123; break &#125; &#125;&#125; 阻塞 channel使用细节和注意事项123456789101112131415161718**1.channel可以只声明为只读，或者只写的性质** //只写 var ch chan-&lt; int ch = make(chan int ,3) //只读 var ch &lt;-chan int ch = make(chan int ,3)2.使用select可以解决从管道取数据的阻塞问题 select&#123; case v:=&lt;-管道: 逻辑 ... default 逻辑 &#125;3.goroutine中使用recover，解决协程中出现的panic，导致程序崩溃问题。 交换式排序法 顺序查找 二分查找 【举例说明】 接口的注意事项和细节 接口-多态","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2021-06-25T07:54:52.000Z","updated":"2021-06-25T07:57:03.326Z","comments":true,"path":"2021/06/25/我的第一篇博客/","link":"","permalink":"http://example.com/2021/06/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一章内容 第二章内容 参考哈哈","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-06-25T07:52:59.827Z","updated":"2021-06-25T07:52:59.827Z","comments":true,"path":"2021/06/25/hello-world/","link":"","permalink":"http://example.com/2021/06/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]}